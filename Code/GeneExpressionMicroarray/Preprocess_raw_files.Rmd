---
title: "Ctr Infection in End1 cells 24h/48h"
author: "Hilmar Berger"
output: 
 html_document:
    toc: true
    toc_depth: 3
    toc_float: false
    number_sections: true
    code_folding: hide
    
pdf_document:
    fig_caption: true
date: "`r format(Sys.time(), '%d %B, %Y %H:%M:%S')`"
---

```{r results='hide', messages=FALSE}
rm(list=ls())
library(limma)
library(pheatmap)
library(xtable)
```

# Introduction

This is a reanalysis of micro arrays generated by Cindrilla Chumduri using End1 cells and infecting with C.trachomatis serovar D for 24h or 48h. Arrays are Agilent design ID 014850 in an dual color design. 
Original analysis was done using Rosetta Resolver. This new analysis uses the separate-channel analysis method as described by Smyth and Altman (BMC Bioinformatics, 2013) which allows to pool replicates across arrays in the two-color design, increasing the power to detect smaller changes.

We compare the infected cells 24h or 48h after infection to the corresponding non-infected timepoints. 

```{r results='hide', messages=FALSE}
# set up the experimental design
exp_design = read.table("./exp_design.tsv",sep="\t", header=T, stringsAsFactors = F)

exp_design$dye_swap = c(F,T,F,T,F,T,F,T)
exp_design$Cy3 = paste(exp_design$ch1_inf,exp_design$ch1_time,sep="_")
exp_design$Cy5 = paste(exp_design$ch2_inf,exp_design$ch2_time,sep="_")

rownames(exp_design)=exp_design$scan_name

d = getwd()
setwd("../../Data/Raw/GeneExpression")
# read data from raw files
RG =read.maimages(exp_design[exp_design$chip_type=="Agilent-014850",]$filename,source="agilent.median")
setwd(d)

# fix outdated chip annotations
new_anno_file = "../../Data/Raw/GeneExpression/Agilent_14850_annotations_2015-09-08.Rdata"
load(new_anno_file)
old_anno = RG$genes
take_over_cols = colnames(old_anno)[!colnames(old_anno) %in% c("GeneName","Description","SystematicName")]
tmp = old_anno[,take_over_cols]
tmp$index=1:nrow(tmp)
tmp = merge(tmp, anno_tab_14850, by.x="ProbeName", by.y="ProbeID", all.x=T, sort=F)
new_col_order = c(take_over_cols, colnames(tmp)[!colnames(tmp) %in% take_over_cols])
new_anno = tmp[order(tmp$index),new_col_order]

RG$genes = new_anno

ed = exp_design
```

## Data overview


### Samples 

```{r results='asis', warning=FALSE}
sel_cols = c("chip_barcode","chip_type","ch1_exp", "scan_ID","dye_swap","Cy3","Cy5")
tmp = ed[,sel_cols]
print.xtable(xtable(tmp,display=rep("s",ncol(tmp)+1), align=paste("|",rep("l|", ncol(tmp)+1)), file="" , include.rownames=F), type="html")
```


## Raw data

```{r, fig.height=8}
par(mar=c(12,4,4,1))
boxplot(data.frame(log2(RG$G)),main="Green", las=2)
boxplot(data.frame(log2(RG$R)),main="Red", las=2)

boxplot(data.frame(log2(RG$Gb)),main="Green bg", las=2)
boxplot(data.frame(log2(RG$Rb)),main="Red bg", las=2)

plotDensities(RG)
```

# Background correction

We here background-correct RG data with method "normexp" and an offset of 50. 

```{r, expr, fig.width=8, fig.height=8}
RG <- backgroundCorrect(RG, method="normexp", offset=50)
RG.b = backgroundCorrect(RG, method="minimum")
```

```{r}
gg = paste(ed[colnames(RG.b$R), "ch1_exp"], ed[colnames(RG.b$R), "Cy3"], ed[colnames(RG.b$R), "Cy5"],ed[colnames(RG.b$R), "scan_ID"], sep="_")
#gg = paste(ed[colnames(RG.b$R), "ch1_exp"], ed[colnames(RG.b$R), "Cy3"], ed[colnames(RG.b$R), "Cy5"], sep="_")
plotDensities(log2(RG.b$G), group=gg, legend="topright", main="G")
plotDensities(log2(RG.b$R), group=gg, legend="topright", main="R")
```


# Within-array normalization

Background corrected data are within-array normalized with methd LOESS. 

```{r}
MA <- normalizeWithinArrays(RG.b, method="loess")
MA.avg <- avereps(MA, ID=MA$genes$ProbeName)
```

```{r, fig.height=8}
limma::plotMA(MA,array=1,status=ifelse(MA$genes$ControlType==1,RG$genes$ProbeName,"gene"),cex=1, legend=F)

op <- par(mar = c(14,4,4,2) + 0.1)
boxplot(data.frame(MA$M),main="M", las=2, cex.names=0.6)
boxplot(data.frame(MA$A),main="A", las=2)
par(op)

gg = ifelse(ed[colnames(MA$M), "scan_ID"] %in% c("16864","16865"), "last two samples (16864,16865)", "all but last two samples")

plotDensities(MA, group=gg, main="Between-array normalized densities")
```


```{r, cor, fig.width=8, fig.height=8}
exp_matrix = MA.avg$M * matrix(rep(ifelse(ed$dye_swap, -1, 1),each=nrow(MA.avg$M)),nrow(MA.avg$M),ncol(MA.avg$M))
dswp = exp_design[colnames(exp_matrix),]$dye_swap
cy3_label = exp_design[colnames(exp_matrix),]$Cy3
cy5_label = exp_design[colnames(exp_matrix),]$Cy5
scan_id = exp_design[colnames(exp_matrix),]$scan_ID
array_label = paste(ifelse(dswp, cy3_label, cy5_label), "_",ifelse(dswp,cy5_label, cy3_label),"_",dswp,"_",scan_id,sep="")
colnames(exp_matrix) = array_label
cc = cor(exp_matrix,method="spearman")
pheatmap(cc)
```


```{r}
ed = exp_design
ed$Short = paste(ed$ch1_inf, ed$ch1_time, ed$ch1_exp, ed$dye_swap, ed$scan_ID, sep="_")
ed$Condition = paste(ed$ch1_time, ed$ch1_inf, ed$ch1_exp,  sep="_")
ed_orig = ed
```

# Between array normalization

We here normalized between arrays using method Aquantile 

```{r}
# Single Channel analysis - all arrays
MA.n <- normalizeBetweenArrays(MA.avg, method="Aquantile")
plotDensities(MA.n)

```


```{r, mds, fig.width=8, fig.height=8}
################################################################################
## MDS on normalized data 
cp = palette(rainbow(8))
data_inp = t(as.matrix(MA.n))

d <- dist(data_inp) # euclidean distances between the rows
fit <- cmdscale(d,eig=TRUE, k=2) # k is the number of dim

# plot solution
x <- fit$points[,1]
y <- fit$points[,2]
cond_short = unlist(sapply(strsplit(ed[rownames(data_inp),]$Condition,"_"), function(x) paste(x[1:2], collapse="_") ))
cc = cp[as.numeric(factor(cond_short))]
plot(x, y, xlab="Coordinate 1", ylab="Coordinate 2", main="Metric MDS, all samples", type="n", ylim=c(min(y)-50, max(y)+50), xlim=c(min(x)-50, max(x)+200))
points(x, y, col=cc)
#text(x,y,labels=ed[rownames(data_inp),]$sample_ID, col=cp[as.numeric(factor(ed[rownames(data_inp),]$Tissue.Status))])
text(x,y,labels=ed[rownames(data_inp),]$Short, col=cc, cex=.8, pos=4)
################################################################################

```


## Control probes

The following control probes exist on the arrays used in this experiment:

* Corner associated (used for orientation purposes during scanning)
  * Bright corner 
  * Dark corner 
* Negative controls
  * 3xSLv1 (hairpin probe that does not hybridize well with any possible RNA)
* Positive controls
  * Human GAPDH and PGK1 probes
  * Deletion stringency probes (DCP, probe with varying number of insertions/changes with respect to reference; the number after the "_" denotes the number of differences to the reference which should correlate with lower expression)
  * E1A_r60: spike-in probes with concentrations that should cover the whole dynamic range of the array

There are a few other expression probes that are used by Agilent's feature extraction/QC pipeline. 

```{r, qc_probes, fig.width=12, fig.height=3}
control_probes = which(RG$genes$ControlType!=0)
cp_data = RG$G[control_probes,]
cp_names = RG$genes[control_probes,]
selected_controls = ifelse(substr(cp_names$ProbeName,1,4)=="ERCC",F,T)

# control probes
for (i in 1:ncol(cp_data)) {
  boxplot(log2(cp_data[selected_controls,i]) ~ factor(cp_names$ProbeName[selected_controls]),las=2, main=paste("Sample",i), outline=F)
}
```


```{r}
ed=ed_orig
save(ed, RG, MA, MA.n, file="../../Data/Processed/GeneExpression/CtrD_Inf_micro_array_preprocessed_data.Rdata")
```

```{r}
sessionInfo()
```

